/**
 * 乐观锁
 * 每次去拿数据的时候都认为别人不会修改，所以不会上锁，不会锁住被操作的对象，
 * 但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，
 * 如果数据和一开始拿到的不一样，说明数据发生变化，就不能继续刚才的更新数据过程了
 * 会选择放弃，报错，重试等策略
 *
 * 可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，
 * 像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁
 *
 * 在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的
 * 原子类，并发容器都是典型的例子
 *
 * 此外，git版本管理器就是典型的乐观锁，如果远端仓库的版本号和本地版本号的不一样
 * 就表示远端代码已被修改，这次的提交就失败
 *
 * 乐观锁虽然一开始的开销比悲观锁小，但是如果自旋时间很长或者不停重试，那么消耗的资源也会越来越多
 * 适合并发写入少的情况、大部分是读取的场景
 *
 * @Author: zzStar
 * @Date: 10-09-2020 14:24
 */
public class OptimisticLock {


}

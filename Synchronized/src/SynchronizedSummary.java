/**
 * Synchronized使用总结
 *
 * @Author: zzStar
 * @Date: 10-21-2020 18:31
 */
public class SynchronizedSummary {

    /**
     * JVM会自动通过使用monitor来加锁和解锁，保证了同时只有一个线程可以执行指定代码，从而保证了线程安全，具有可重入和不可中断的性质
     */

    /**
     *  作用 ->
     *     能够保证在 同一时刻❗ 最多 只有一个❗ 线程执行该段代码，以达到保证并发安全的效果
     */


    /**
     *  对象锁
     *    -> 包括方法锁（默认锁对象为this当前实例对象）和 同步代码块锁（自己指定锁对象）
     *  类锁
     *    -> 指synchronized修饰静态的方法或指定锁为Class对象
     */

    /**
     *  几种情况
     *    -> 一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待
     *    -> 每个实例都对应有自己的一把锁，不同实例之间互不影响，例外：锁对象是.class以及synchronized修饰的是static时，所有的对象共用同一把类锁
     *    -> 无论是方法正常执行完毕或者方法抛出异常，都会释放锁
     *    -> 另外，在synchronized中调用了没有被synchronized修饰的方法，不是线程安全的！
     */

    /**
     * 缺陷 ->
     *  效率低：锁的释放情况少，视图获得锁时不能设定超时，不能中断一个正在试图获得锁的线程
     *  不够灵活：加锁和释放的时机单一
     *  无法知道是否成功获得锁
     */
}

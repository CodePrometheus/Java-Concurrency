package com.star.deadlock;

/**
 * 死锁总结
 *
 * @Author: zzStar
 * @Date: 10-20-2020 14:51
 */
public class DeadLockSummary {

    /**
     * 1.发生在并发中
     * 2.互不相让
     * 3.如果多个线程11之间的依赖关系是环形，存在环路的锁的依赖关系，也可能会发生死锁
     */


    /**
     *  死锁发生的4个必要条件
     *   -> 互斥条件
     *   -> 请求与保持条件
     *   -> 不剥夺条件
     *   -> 循环等待条件
     */


    /**
     * 进餐问题的解决方案
     *  -> 服务员检查（避免策略）
     *  -> 改变一个哲学家拿叉子的顺序（避免策略）
     *  -> 餐票（避免策略）
     *  -> 领导调节（检测与恢复策略）
     */


    /**
     * 避免死锁的tips
     *  -> 设置超时时间（tryLock(long timeout,TimeUnit unit)），synchronized不具备尝试锁的能力
     *  -> 多使用并发类，而不是自己设计锁（如ConcurrentHashMap，juc.atomic）
     *  -> 尽量降低锁的使用粒度：用不同的锁而不是一个锁
     *  -> 如果能使用同步代码块，就不使用同步方法：自己指定锁对象
     *  -> 新建线程起有意义的名字，便于排查
     *  -> 避免锁的嵌套
     *  -> 分配资源前先看能不能收回来：银行家算法
     *  -> 尽量不要几个功能用同一把锁：专锁专用
     */


    /**  其他活跃性问题
     * 活锁 ->  虽然线程并没有阻塞，也始终在运行，但是程序却得不到进展，因为线程始终重复做同样的事
     * 饥饿 ->  当线程需要某些资源（例如CPU），但是却始终得不到
     *         -> 如线程的优先级设置得过于低，或者某些线程持有锁同时又无限循环从而不释放锁，或者某程序始终占用某文件的写锁
     */

    /**
     *  活锁
     *   原因：重试机制不变，消息队列始终重试
     *   解决：以太网的指数退避算法，加入随机因素
     */

}

/**
 * 内存模型总结与问题
 *
 * @Author: zzStar
 * @Date: 10-19-2020 16:09
 */
public class JmmSummary {

    /**
     * JVM内存结构，和Java虚拟机的运行时区域有关
     *  -> 运行时数据区(方法区，堆 | Java栈，本地方法栈，程序计数器)
     *
     * Java内存模型，和Java的并发编程有关
     *  -> 实际上是一组规范，需要各个JVM的实现来遵守JMM规范，以便于开发者可以利用这些规范，更方便地开发多线程程序
     *  -> JVM是工具类和关键字的原理，volatile、synchronized、lock等原理都是JVM
     *  -> 没有JVM，就需要自己指定什么时候用内存栅栏（如工作内存和主内存之间的拷贝与同步）
     *
     * Java对象模型，和Java对象在虚拟机中的表现形式有关
     *  -> 栈，堆，方法区
     */

    /**
     * 为什么会有可见性问题❓
     *  -> CPU有多级缓存，导致读的数据过期
     *       1.高速缓存的容量比主内存小，但是速度仅次于寄存器，所有在CPU和主内存之间就多了Cache层
     *       2.线程间的对于共享变量的可见性问题不是直接由多核引起的，而是由多缓存引起的
     */

    /**
     * 所以，Java屏蔽了这些底层细节，JMM定义了一套读写内存数据的规范，JMM抽象了主内存和本地内存的概念
     *      其中，本地内存并不是真的是一块给每个线程分配的内存，而是JMM的一个抽象，是对于寄存器、一级缓存、二级缓存等的抽象
     */


    /**
     *  主内存和本地内存的关系
     *    -> 所有变量都存储在主内存中，同时每个线程也有自己独立的工作内存，工作内存中的变量内容是主内存中的拷贝
     *    -> 线程不能直接读写主内存中的变量，而是只能❗操作自己工作内存中的变量，然后再同步到主内存中
     *    -> 主内存是多个线程共享的，但线程间不共享工作内存，如果线程间需要通信，必须借助主内存中转❗来完成
     *
     *    所有的共享变量存在于主内存中，每个线程有自己的本地内存，而且线程读写共享数据也是通过本地内存交换的，所有才导致了可见性问题
     */

}